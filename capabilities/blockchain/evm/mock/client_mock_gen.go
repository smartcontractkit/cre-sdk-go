// Code generated by github.com/smartcontractkit/cre-sdk-go/generator/protoc-gen-cre, DO NOT EDIT.

package evmmock

import (
	"context"
	"fmt"
	"strconv"
	"testing"

	"google.golang.org/protobuf/types/known/anypb"

	"github.com/smartcontractkit/cre-sdk-go/capabilities/blockchain/evm"

	"google.golang.org/protobuf/types/known/emptypb"

	sdkpb "github.com/smartcontractkit/chainlink-protos/cre/go/sdk"
	"github.com/smartcontractkit/cre-sdk-go/cre/testutils/registry"
)

// avoid unused imports
var _ = registry.Registry{}

func NewClientCapability(ChainSelector uint64, t testing.TB) (*ClientCapability, error) {
	c := &ClientCapability{
		ChainSelector: ChainSelector,
	}
	reg := registry.GetRegistry(t)
	err := reg.RegisterCapability(c)
	return c, err
}

type ClientCapability struct {
	ChainSelector uint64
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 add the default to the call

	CallContract func(ctx context.Context, input *evm.CallContractRequest) (*evm.CallContractReply, error)
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 add the default to the call

	FilterLogs func(ctx context.Context, input *evm.FilterLogsRequest) (*evm.FilterLogsReply, error)
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 add the default to the call

	BalanceAt func(ctx context.Context, input *evm.BalanceAtRequest) (*evm.BalanceAtReply, error)
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 add the default to the call

	EstimateGas func(ctx context.Context, input *evm.EstimateGasRequest) (*evm.EstimateGasReply, error)
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 add the default to the call

	GetTransactionByHash func(ctx context.Context, input *evm.GetTransactionByHashRequest) (*evm.GetTransactionByHashReply, error)
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 add the default to the call

	GetTransactionReceipt func(ctx context.Context, input *evm.GetTransactionReceiptRequest) (*evm.GetTransactionReceiptReply, error)
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 add the default to the call

	HeaderByNumber func(ctx context.Context, input *evm.HeaderByNumberRequest) (*evm.HeaderByNumberReply, error)
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 add the default to the call

	RegisterLogTracking func(ctx context.Context, input *evm.RegisterLogTrackingRequest) (*emptypb.Empty, error)
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 add the default to the call

	UnregisterLogTracking func(ctx context.Context, input *evm.UnregisterLogTrackingRequest) (*emptypb.Empty, error)
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 add the default to the call

	WriteReport func(ctx context.Context, input *evm.WriteReportRequest) (*evm.WriteReportReply, error)
}

func (c *ClientCapability) Invoke(ctx context.Context, request *sdkpb.CapabilityRequest) *sdkpb.CapabilityResponse {
	capResp := &sdkpb.CapabilityResponse{}
	switch request.Method {
	case "CallContract":
		input := &evm.CallContractRequest{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			break
		}

		if c.CallContract == nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: "no stub provided for CallContract"}
			break
		}
		resp, err := c.CallContract(ctx, input)
		if err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
		} else {
			payload, err := anypb.New(resp)
			if err == nil {
				capResp.Response = &sdkpb.CapabilityResponse_Payload{Payload: payload}
			} else {
				capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			}
		}
	case "FilterLogs":
		input := &evm.FilterLogsRequest{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			break
		}

		if c.FilterLogs == nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: "no stub provided for FilterLogs"}
			break
		}
		resp, err := c.FilterLogs(ctx, input)
		if err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
		} else {
			payload, err := anypb.New(resp)
			if err == nil {
				capResp.Response = &sdkpb.CapabilityResponse_Payload{Payload: payload}
			} else {
				capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			}
		}
	case "BalanceAt":
		input := &evm.BalanceAtRequest{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			break
		}

		if c.BalanceAt == nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: "no stub provided for BalanceAt"}
			break
		}
		resp, err := c.BalanceAt(ctx, input)
		if err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
		} else {
			payload, err := anypb.New(resp)
			if err == nil {
				capResp.Response = &sdkpb.CapabilityResponse_Payload{Payload: payload}
			} else {
				capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			}
		}
	case "EstimateGas":
		input := &evm.EstimateGasRequest{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			break
		}

		if c.EstimateGas == nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: "no stub provided for EstimateGas"}
			break
		}
		resp, err := c.EstimateGas(ctx, input)
		if err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
		} else {
			payload, err := anypb.New(resp)
			if err == nil {
				capResp.Response = &sdkpb.CapabilityResponse_Payload{Payload: payload}
			} else {
				capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			}
		}
	case "GetTransactionByHash":
		input := &evm.GetTransactionByHashRequest{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			break
		}

		if c.GetTransactionByHash == nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: "no stub provided for GetTransactionByHash"}
			break
		}
		resp, err := c.GetTransactionByHash(ctx, input)
		if err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
		} else {
			payload, err := anypb.New(resp)
			if err == nil {
				capResp.Response = &sdkpb.CapabilityResponse_Payload{Payload: payload}
			} else {
				capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			}
		}
	case "GetTransactionReceipt":
		input := &evm.GetTransactionReceiptRequest{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			break
		}

		if c.GetTransactionReceipt == nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: "no stub provided for GetTransactionReceipt"}
			break
		}
		resp, err := c.GetTransactionReceipt(ctx, input)
		if err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
		} else {
			payload, err := anypb.New(resp)
			if err == nil {
				capResp.Response = &sdkpb.CapabilityResponse_Payload{Payload: payload}
			} else {
				capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			}
		}
	case "HeaderByNumber":
		input := &evm.HeaderByNumberRequest{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			break
		}

		if c.HeaderByNumber == nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: "no stub provided for HeaderByNumber"}
			break
		}
		resp, err := c.HeaderByNumber(ctx, input)
		if err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
		} else {
			payload, err := anypb.New(resp)
			if err == nil {
				capResp.Response = &sdkpb.CapabilityResponse_Payload{Payload: payload}
			} else {
				capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			}
		}
	case "RegisterLogTracking":
		input := &evm.RegisterLogTrackingRequest{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			break
		}

		if c.RegisterLogTracking == nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: "no stub provided for RegisterLogTracking"}
			break
		}
		resp, err := c.RegisterLogTracking(ctx, input)
		if err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
		} else {
			payload, err := anypb.New(resp)
			if err == nil {
				capResp.Response = &sdkpb.CapabilityResponse_Payload{Payload: payload}
			} else {
				capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			}
		}
	case "UnregisterLogTracking":
		input := &evm.UnregisterLogTrackingRequest{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			break
		}

		if c.UnregisterLogTracking == nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: "no stub provided for UnregisterLogTracking"}
			break
		}
		resp, err := c.UnregisterLogTracking(ctx, input)
		if err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
		} else {
			payload, err := anypb.New(resp)
			if err == nil {
				capResp.Response = &sdkpb.CapabilityResponse_Payload{Payload: payload}
			} else {
				capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			}
		}
	case "WriteReport":
		input := &evm.WriteReportRequest{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			break
		}

		if c.WriteReport == nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: "no stub provided for WriteReport"}
			break
		}
		resp, err := c.WriteReport(ctx, input)
		if err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
		} else {
			payload, err := anypb.New(resp)
			if err == nil {
				capResp.Response = &sdkpb.CapabilityResponse_Payload{Payload: payload}
			} else {
				capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			}
		}
	default:
		capResp.Response = &sdkpb.CapabilityResponse_Error{Error: fmt.Sprintf("method %s not found", request.Method)}
	}

	return capResp
}

func (c *ClientCapability) ID() string {
	return "evm" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0"
}
