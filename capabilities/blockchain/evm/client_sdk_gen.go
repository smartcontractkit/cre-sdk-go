// Code generated by github.com/smartcontractkit/cre-sdk-go/generator/protoc-gen-cre, DO NOT EDIT.

package evm

import (
	"errors"
	"fmt"
	"strconv"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/anypb"

	sdkpb "github.com/smartcontractkit/chainlink-common/pkg/workflows/sdk/v2/pb"
	"github.com/smartcontractkit/cre-sdk-go/cre"
	"google.golang.org/protobuf/types/known/emptypb"
)

type Client struct {
	ChainSelector uint64
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 allow defaults for capabilities
}

func (c *Client) CallContract(runtime cre.Runtime, input *CallContractRequest) cre.Promise[*CallContractReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*CallContractReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "evm" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "CallContract",
	}), func(i *sdkpb.CapabilityResponse) (*CallContractReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &CallContractReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) FilterLogs(runtime cre.Runtime, input *FilterLogsRequest) cre.Promise[*FilterLogsReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*FilterLogsReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "evm" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "FilterLogs",
	}), func(i *sdkpb.CapabilityResponse) (*FilterLogsReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &FilterLogsReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) BalanceAt(runtime cre.Runtime, input *BalanceAtRequest) cre.Promise[*BalanceAtReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*BalanceAtReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "evm" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "BalanceAt",
	}), func(i *sdkpb.CapabilityResponse) (*BalanceAtReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &BalanceAtReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) EstimateGas(runtime cre.Runtime, input *EstimateGasRequest) cre.Promise[*EstimateGasReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*EstimateGasReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "evm" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "EstimateGas",
	}), func(i *sdkpb.CapabilityResponse) (*EstimateGasReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &EstimateGasReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) GetTransactionByHash(runtime cre.Runtime, input *GetTransactionByHashRequest) cre.Promise[*GetTransactionByHashReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*GetTransactionByHashReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "evm" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "GetTransactionByHash",
	}), func(i *sdkpb.CapabilityResponse) (*GetTransactionByHashReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &GetTransactionByHashReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) GetTransactionReceipt(runtime cre.Runtime, input *GetTransactionReceiptRequest) cre.Promise[*GetTransactionReceiptReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*GetTransactionReceiptReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "evm" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "GetTransactionReceipt",
	}), func(i *sdkpb.CapabilityResponse) (*GetTransactionReceiptReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &GetTransactionReceiptReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) HeaderByNumber(runtime cre.Runtime, input *HeaderByNumberRequest) cre.Promise[*HeaderByNumberReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*HeaderByNumberReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "evm" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "HeaderByNumber",
	}), func(i *sdkpb.CapabilityResponse) (*HeaderByNumberReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &HeaderByNumberReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) RegisterLogTracking(runtime cre.Runtime, input *RegisterLogTrackingRequest) cre.Promise[*emptypb.Empty] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*emptypb.Empty](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "evm" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "RegisterLogTracking",
	}), func(i *sdkpb.CapabilityResponse) (*emptypb.Empty, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &emptypb.Empty{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) UnregisterLogTracking(runtime cre.Runtime, input *UnregisterLogTrackingRequest) cre.Promise[*emptypb.Empty] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*emptypb.Empty](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "evm" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "UnregisterLogTracking",
	}), func(i *sdkpb.CapabilityResponse) (*emptypb.Empty, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &emptypb.Empty{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func LogTrigger(chainSelector uint64, config *FilterLogTriggerRequest) cre.Trigger[*Log, *Log] {
	configAny := &anypb.Any{}
	_ = anypb.MarshalFrom(configAny, config, proto.MarshalOptions{Deterministic: true})
	return &clientLogTrigger{
		ChainSelector: chainSelector,

		config: configAny,
	}
}

type clientLogTrigger struct {
	config        *anypb.Any
	ChainSelector uint64
}

func (*clientLogTrigger) IsTrigger() {}

func (*clientLogTrigger) NewT() *Log {
	return &Log{}
}

func (c *clientLogTrigger) CapabilityID() string {
	return "evm" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0"
}

func (*clientLogTrigger) Method() string {
	return "LogTrigger"
}

func (t *clientLogTrigger) ConfigAsAny() *anypb.Any {
	return t.config
}

func (t *clientLogTrigger) Adapt(trigger *Log) (*Log, error) {
	return trigger, nil
}

type WriteCreReportRequest struct {
	Receiver []byte

	Report *cre.Report

	GasConfig *GasConfig
}

// X_GeneratedCodeOnly_WrapWriteCreReportRequest is only meant to be used by the generated code.
func X_GeneratedCodeOnly_Wrap_WriteCreReportRequest(i *WriteReportRequest) (*WriteCreReportRequest, error) { //nolint

	receiver := i.Receiver

	report, err := cre.X_GeneratedCodeOnly_WrapReport(i.Report)
	if err != nil {
		return nil, fmt.Errorf("failed to wrap report for field %s: %w", "Report", err)
	}

	gasConfig := i.GasConfig

	return &WriteCreReportRequest{

		Receiver:  receiver,
		Report:    report,
		GasConfig: gasConfig,
	}, nil
}

// X_GeneratedCodeOnly_Unwrap is only meant to be used by the generated code.
func (i *WriteCreReportRequest) X_GeneratedCodeOnly_Unwrap() *WriteReportRequest { //nolint
	return &WriteReportRequest{

		Receiver:  i.Receiver,
		Report:    i.Report.X_GeneratedCodeOnly_Unwrap(),
		GasConfig: i.GasConfig,
	}
}

func (c *Client) WriteReport(runtime cre.Runtime, input *WriteCreReportRequest) cre.Promise[*WriteReportReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input.X_GeneratedCodeOnly_Unwrap(), proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*WriteReportReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "evm" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "WriteReport",
	}), func(i *sdkpb.CapabilityResponse) (*WriteReportReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &WriteReportReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

const AvalancheMainnet = 6433500567565415381

const AvalancheTestnetFuji = 14767482510784806043

const BinanceSmartChainMainnetOpbnb1 = 465944652040885897

const BinanceSmartChainTestnetOpbnb1 = 13274425992935471758

const EthereumMainnet = 5009297550715157269

const EthereumMainnetArbitrum1 = 4949039107694359620

const EthereumMainnetOptimism1 = 3734403246176062136

const EthereumTestnetSepolia = 16015286601757825753

const EthereumTestnetSepoliaArbitrum1 = 3478487238524512106

const EthereumTestnetSepoliaBase1 = 10344971235874465080

const EthereumTestnetSepoliaOptimism1 = 5224473277236331295

const PolygonMainnet = 4051577828743386545

const PolygonTestnetAmoy = 16281711391670634445

func ChainSelectorFromName(name string) (uint64, error) {
	switch name {
	case "avalanche-mainnet":
		return AvalancheMainnet, nil
	case "avalanche-testnet-fuji":
		return AvalancheTestnetFuji, nil
	case "binance_smart_chain-mainnet-opbnb-1":
		return BinanceSmartChainMainnetOpbnb1, nil
	case "binance_smart_chain-testnet-opbnb-1":
		return BinanceSmartChainTestnetOpbnb1, nil
	case "ethereum-mainnet":
		return EthereumMainnet, nil
	case "ethereum-mainnet-arbitrum-1":
		return EthereumMainnetArbitrum1, nil
	case "ethereum-mainnet-optimism-1":
		return EthereumMainnetOptimism1, nil
	case "ethereum-testnet-sepolia":
		return EthereumTestnetSepolia, nil
	case "ethereum-testnet-sepolia-arbitrum-1":
		return EthereumTestnetSepoliaArbitrum1, nil
	case "ethereum-testnet-sepolia-base-1":
		return EthereumTestnetSepoliaBase1, nil
	case "ethereum-testnet-sepolia-optimism-1":
		return EthereumTestnetSepoliaOptimism1, nil
	case "polygon-mainnet":
		return PolygonMainnet, nil
	case "polygon-testnet-amoy":
		return PolygonTestnetAmoy, nil
	default:
		return 0, errors.New("unknown ChainSelector" + name)
	}
}
