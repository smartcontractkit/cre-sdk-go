// Code generated by github.com/smartcontractkit/cre-sdk-go/generator/protoc-gen-cre, DO NOT EDIT.

package solana

import (
	"errors"
	"fmt"
	"strconv"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/anypb"

	sdkpb "github.com/smartcontractkit/chainlink-protos/cre/go/sdk"
	"github.com/smartcontractkit/cre-sdk-go/cre"
)

type Client struct {
	ChainSelector uint64
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 allow defaults for capabilities
}

func (c *Client) GetAccountInfoWithOpts(runtime cre.Runtime, input *GetAccountInfoWithOptsRequest) cre.Promise[*GetAccountInfoWithOptsReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*GetAccountInfoWithOptsReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "solana" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "GetAccountInfoWithOpts",
	}), func(i *sdkpb.CapabilityResponse) (*GetAccountInfoWithOptsReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &GetAccountInfoWithOptsReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) GetBalance(runtime cre.Runtime, input *GetBalanceRequest) cre.Promise[*GetBalanceReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*GetBalanceReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "solana" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "GetBalance",
	}), func(i *sdkpb.CapabilityResponse) (*GetBalanceReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &GetBalanceReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) GetBlock(runtime cre.Runtime, input *GetBlockRequest) cre.Promise[*GetBlockReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*GetBlockReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "solana" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "GetBlock",
	}), func(i *sdkpb.CapabilityResponse) (*GetBlockReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &GetBlockReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) GetFeeForMessage(runtime cre.Runtime, input *GetFeeForMessageRequest) cre.Promise[*GetFeeForMessageReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*GetFeeForMessageReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "solana" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "GetFeeForMessage",
	}), func(i *sdkpb.CapabilityResponse) (*GetFeeForMessageReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &GetFeeForMessageReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) GetMultipleAccountsWithOpts(runtime cre.Runtime, input *GetMultipleAccountsWithOptsRequest) cre.Promise[*GetMultipleAccountsWithOptsReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*GetMultipleAccountsWithOptsReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "solana" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "GetMultipleAccountsWithOpts",
	}), func(i *sdkpb.CapabilityResponse) (*GetMultipleAccountsWithOptsReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &GetMultipleAccountsWithOptsReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) GetSignatureStatuses(runtime cre.Runtime, input *GetSignatureStatusesRequest) cre.Promise[*GetSignatureStatusesReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*GetSignatureStatusesReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "solana" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "GetSignatureStatuses",
	}), func(i *sdkpb.CapabilityResponse) (*GetSignatureStatusesReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &GetSignatureStatusesReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) GetSlotHeight(runtime cre.Runtime, input *GetSlotHeightRequest) cre.Promise[*GetSlotHeightReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*GetSlotHeightReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "solana" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "GetSlotHeight",
	}), func(i *sdkpb.CapabilityResponse) (*GetSlotHeightReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &GetSlotHeightReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func (c *Client) GetTransaction(runtime cre.Runtime, input *GetTransactionRequest) cre.Promise[*GetTransactionReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input, proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*GetTransactionReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "solana" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "GetTransaction",
	}), func(i *sdkpb.CapabilityResponse) (*GetTransactionReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &GetTransactionReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

func LogTrigger(chainSelector uint64, config *FilterLogTriggerRequest) cre.Trigger[*Log, *Log] {
	configAny := &anypb.Any{}
	_ = anypb.MarshalFrom(configAny, config, proto.MarshalOptions{Deterministic: true})
	return &clientLogTrigger{
		ChainSelector: chainSelector,

		config: configAny,
	}
}

type clientLogTrigger struct {
	config        *anypb.Any
	ChainSelector uint64
}

func (*clientLogTrigger) IsTrigger() {}

func (*clientLogTrigger) NewT() *Log {
	return &Log{}
}

func (c *clientLogTrigger) CapabilityID() string {
	return "solana" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0"
}

func (*clientLogTrigger) Method() string {
	return "LogTrigger"
}

func (t *clientLogTrigger) ConfigAsAny() *anypb.Any {
	return t.config
}

func (t *clientLogTrigger) Adapt(trigger *Log) (*Log, error) {
	return trigger, nil
}

type WriteCreReportRequest struct {
	RemainingAccounts []*AccountMeta // accounts that are required by the receiver to accept the report

	Receiver []byte // 32 bytes receiver

	ComputeConfig *ComputeConfig

	Report *cre.Report
}

// X_GeneratedCodeOnly_WrapWriteCreReportRequest is only meant to be used by the generated code.
func X_GeneratedCodeOnly_Wrap_WriteCreReportRequest(i *WriteReportRequest) (*WriteCreReportRequest, error) { //nolint

	remainingAccounts := i.RemainingAccounts

	receiver := i.Receiver

	computeConfig := i.ComputeConfig

	report, err := cre.X_GeneratedCodeOnly_WrapReport(i.Report)
	if err != nil {
		return nil, fmt.Errorf("failed to wrap report for field %s: %w", "Report", err)
	}

	return &WriteCreReportRequest{

		RemainingAccounts: remainingAccounts,
		Receiver:          receiver,
		ComputeConfig:     computeConfig,
		Report:            report,
	}, nil
}

// X_GeneratedCodeOnly_Unwrap is only meant to be used by the generated code.
func (i *WriteCreReportRequest) X_GeneratedCodeOnly_Unwrap() *WriteReportRequest { //nolint
	return &WriteReportRequest{

		RemainingAccounts: i.RemainingAccounts,
		Receiver:          i.Receiver,
		ComputeConfig:     i.ComputeConfig,
		Report:            i.Report.X_GeneratedCodeOnly_Unwrap(),
	}
}

func (c *Client) WriteReport(runtime cre.Runtime, input *WriteCreReportRequest) cre.Promise[*WriteReportReply] {
	wrapped := &anypb.Any{}
	err := anypb.MarshalFrom(wrapped, input.X_GeneratedCodeOnly_Unwrap(), proto.MarshalOptions{Deterministic: true})
	if err != nil {
		return cre.PromiseFromResult[*WriteReportReply](nil, err)
	}

	capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
		Id:      "solana" + ":ChainSelector:" + strconv.FormatUint(c.ChainSelector, 10) + "@1.0.0",
		Payload: wrapped,
		Method:  "WriteReport",
	}), func(i *sdkpb.CapabilityResponse) (*WriteReportReply, error) {
		switch payload := i.Response.(type) {
		case *sdkpb.CapabilityResponse_Error:
			return nil, errors.New(payload.Error)
		case *sdkpb.CapabilityResponse_Payload:
			output := &WriteReportReply{}
			err = payload.Payload.UnmarshalTo(output)
			return output, err
		default:
			return nil, errors.New("unexpected response type")
		}
	})

	return capCallResponse

}

const SolanaDevnet = 16423721717087811551

const SolanaMainnet = 124615329519749607

const SolanaTestnet = 6302590918974934319

func ChainSelectorFromName(name string) (uint64, error) {
	switch name {
	case "solana-devnet":
		return SolanaDevnet, nil
	case "solana-mainnet":
		return SolanaMainnet, nil
	case "solana-testnet":
		return SolanaTestnet, nil
	default:
		return 0, errors.New("unknown ChainSelector" + name)
	}
}
