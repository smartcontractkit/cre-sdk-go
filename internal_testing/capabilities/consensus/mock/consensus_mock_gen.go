// Code generated by github.com/smartcontractkit/cre-sdk-go/generator/protoc-gen-cre, DO NOT EDIT.

package consensusmock

import (
	"context"
	"fmt"
	"testing"

	"google.golang.org/protobuf/types/known/anypb"

	"github.com/smartcontractkit/chainlink-protos/cre/go/sdk"

	"github.com/smartcontractkit/chainlink-protos/cre/go/values/pb"

	sdkpb "github.com/smartcontractkit/chainlink-protos/cre/go/sdk"
	"github.com/smartcontractkit/cre-sdk-go/cre/testutils/registry"
)

// avoid unused imports
var _ = registry.Registry{}

func NewConsensusCapability(t testing.TB) (*ConsensusCapability, error) {
	c := &ConsensusCapability{}
	reg := registry.GetRegistry(t)
	err := reg.RegisterCapability(c)
	return c, err
}

type ConsensusCapability struct {
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 add the default to the call

	Simple func(ctx context.Context, input *sdk.SimpleConsensusInputs) (*pb.Value, error)
	// TODO: https://smartcontract-it.atlassian.net/browse/CAPPL-799 add the default to the call

	Report func(ctx context.Context, input *sdk.ReportRequest) (*sdk.ReportResponse, error)
}

func (c *ConsensusCapability) Invoke(ctx context.Context, request *sdkpb.CapabilityRequest) *sdkpb.CapabilityResponse {
	capResp := &sdkpb.CapabilityResponse{}
	switch request.Method {
	case "Simple":
		input := &sdk.SimpleConsensusInputs{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			break
		}

		if c.Simple == nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: "no stub provided for Simple"}
			break
		}
		resp, err := c.Simple(ctx, input)
		if err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
		} else {
			payload, err := anypb.New(resp)
			if err == nil {
				capResp.Response = &sdkpb.CapabilityResponse_Payload{Payload: payload}
			} else {
				capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			}
		}
	case "Report":
		input := &sdk.ReportRequest{}
		if err := request.Payload.UnmarshalTo(input); err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			break
		}

		if c.Report == nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: "no stub provided for Report"}
			break
		}
		resp, err := c.Report(ctx, input)
		if err != nil {
			capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
		} else {
			payload, err := anypb.New(resp)
			if err == nil {
				capResp.Response = &sdkpb.CapabilityResponse_Payload{Payload: payload}
			} else {
				capResp.Response = &sdkpb.CapabilityResponse_Error{Error: err.Error()}
			}
		}
	default:
		capResp.Response = &sdkpb.CapabilityResponse_Error{Error: fmt.Sprintf("method %s not found", request.Method)}
	}

	return capResp
}

func (c *ConsensusCapability) ID() string {
	return "consensus@1.0.0"
}
