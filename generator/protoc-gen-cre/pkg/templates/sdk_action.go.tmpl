{{define "action_method"}}
{{template "wrap_report" (dict "Message" .Method.Input "GoPackageName" .GoPackageName)}}
{{template "wrap_report" (dict "Message" .Method.Output "GoPackageName" .GoPackageName)}}
{{ $inputIdent := WrapMessage .Method.Input }}
{{ $outputIdent := WrapMessage .Method.Output }}

{{ if eq .Mode "Node"}}
type {{.Method.GoName}}er struct  {
    client *{{.Service.GoName}}
    nodeRuntime cre.NodeRuntime
}

{{ if .Method.Comments.Leading.String }}//{{.Method.GoName}} {{CleanComments .Method.Comments.Leading.String}} {{ end }}
func (c *{{.Method.GoName}}er) {{.Method.GoName}}(input *{{name $inputIdent .GoPackageName}}) cre.Promise[*{{name $outputIdent .GoPackageName}}]  { {{- if .Comments.Trailing.String }}// {{CleanComments .Comments.Trailing.String}} {{ end }}
    return c.client.{{.Method.GoName}}(c.nodeRuntime, input)
}

//{{.Method.GoName}} Allows usage of `{{.Method.GoName}}er` with Byzantine fault tolerance.
func {{.Method.GoName}}[C, T any](
    config C,
    runtime cre.Runtime,
    client *{{.Service.GoName}},
    fn func(config C, logger *slog.Logger, {{LowerFirst .Method.GoName}}er *{{.Method.GoName}}er) (T, error),
    ca cre.ConsensusAggregation[T]) cre.Promise[T] {
    wrapped := func(config C, nodeRuntime cre.NodeRuntime) (T, error) {
        {{LowerFirst .Method.GoName}}er := {{.Method.GoName}}er { client: client, nodeRuntime: nodeRuntime }
        return fn(config, runtime.Logger(), &{{LowerFirst .Method.GoName}}er)
    }

    return cre.RunInNodeMode(config, runtime, wrapped, ca)
}
{{ end }}

{{ if .Method.Comments.Leading.String }}//{{.Method.GoName}} {{CleanComments .Method.Comments.Leading.String}} {{ end }}
func (c *{{.Service.GoName}}) {{.Method.GoName}}(runtime cre.{{.Mode}}Runtime, input *{{name $inputIdent .GoPackageName}}) cre.Promise[*{{name $outputIdent .GoPackageName}}] { {{- if .Comments.Trailing.String }}// {{CleanComments .Comments.Trailing.String}} {{ end }}
    wrapped := &anypb.Any{}
    err := anypb.MarshalFrom(wrapped, input{{- if ne $inputIdent .InputType -}}.X_GeneratedCodeOnly_Unwrap(){{- end -}}, proto.MarshalOptions{Deterministic: true})
    if err != nil {
        return cre.PromiseFromResult[*{{name $outputIdent .GoPackageName}}](nil, err)
    }

    capCallResponse := cre.Then(runtime.CallCapability(&sdkpb.CapabilityRequest{
        Id:      {{FullCapabilityId .Service}},
        Payload: wrapped,
        Method:  "{{.Method.GoName}}",
    }), func(i *sdkpb.CapabilityResponse) (*{{name .OutputType .GoPackageName}}, error) {
        switch payload := i.Response.(type) {
        case *sdkpb.CapabilityResponse_Error:
            return nil, errors.New(payload.Error)
        case *sdkpb.CapabilityResponse_Payload:
            output := &{{name .OutputType .GoPackageName}}{}
            err = payload.Payload.UnmarshalTo(output)
            return output, err
        default:
            return nil, errors.New("unexpected response type")
        }
    })
    {{ if ne $outputIdent .OutputType -}}
    return cre.Then(capCallResponse, {{ImportPath $outputIdent}}.X_GeneratedCodeOnly_Wrap{{$outputIdent.GoName}})
    {{ else }}
    return capCallResponse
    {{ end }}
}
{{end}}
